/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * dlgExportClusterSet.java
 *
 * Created on 21-Mar-2011, 19:49:27
 */
package vortex.gui2;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import samusik.glasscmp.GlassDialog;
import clustering.Cluster;
import clustering.ClusterMember;
import clustering.ClusterSet;
import clustering.Datapoint;
import clustering.Score;
import util.DefaultEntry;
import util.IO;

import util.MatrixOp;
import util.logger;

/**
 *
 * @author Nikolay
 */
public class dlgExportClusterSet extends GlassDialog {
    
    private ClusterSet[] cs;

    /**
     * Creates new form dlgExportClusterSet
     */
    public dlgExportClusterSet(java.awt.Frame parent, ClusterSet[] cs) {
        super(parent, true);
        this.cs = cs;
        initComponents();
        setTitle("Export " + cs.length + " Cluster Set" + (cs.length > 1 ? "s" : ""));
        setBounds(200, 200, 400, 300);
        //cmbScoringMeasure.setModel(new DefaultComboBoxModel(cs[0].getClusters()[0].getComputedScores().toArray()));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        buttonGroup1 = new javax.swing.ButtonGroup();
        chkIncludeScoring = new javax.swing.JCheckBox();
        chkIncludeProfiles = new javax.swing.JCheckBox();
        cmdExport = new samusik.glasscmp.GlassButton();
        txtLenThs = new javax.swing.JTextField();
        chkLenThs = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        getContentPane().setLayout(new java.awt.GridBagLayout());

        chkIncludeScoring.setText("Include scoring information");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 0);
        getContentPane().add(chkIncludeScoring, gridBagConstraints);

        chkIncludeProfiles.setText("Include profiles");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
        getContentPane().add(chkIncludeProfiles, gridBagConstraints);

        cmdExport.setText("Export");
        cmdExport.setMaximumSize(new java.awt.Dimension(100, 28));
        cmdExport.setMinimumSize(new java.awt.Dimension(100, 28));
        cmdExport.setPreferredSize(new java.awt.Dimension(100, 28));
        cmdExport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdExportActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.PAGE_START;
        gridBagConstraints.weightx = 0.1;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
        getContentPane().add(cmdExport, gridBagConstraints);

        txtLenThs.setText("0.9");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 50;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        getContentPane().add(txtLenThs, gridBagConstraints);

        chkLenThs.setText("Euclidean len threshold:");
        chkLenThs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkLenThsActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 0);
        getContentPane().add(chkLenThs, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void cmdExportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdExportActionPerformed
        File f2;
        if ((f2 = IO.chooseFileWithDialog("dlgExportProfiles", "Tab Separated Text (*.txt)", new String[]{"txt"}, true)) != null) {
            
            boolean lookup = false;
            HashMap<String, String> hmLookup = new HashMap<>();
            if (false) {
                File lookupFile = null;//new File(jTextField1.getText());
                try {
                    for (String s : IO.getListOfStringsFromStream(new FileInputStream(lookupFile))) {
                        String s2[] = s.split("\t");
                        hmLookup.put(s2[0], s2[1]);
                    }
                } catch (FileNotFoundException ex) {
                    logger.showException(ex);
                }
                lookup = true;
            }
            
            boolean kgg = f2.getName().toLowerCase().endsWith("kgg");
            for (int j = 0; j < cs.length; j++) {
                ArrayList<String[]> rows = new ArrayList<>();
                
                String p = f2.getPath();
                int idx = p.lastIndexOf(".");
                if (idx == -1) {
                    idx = p.length();
                }
                p = p.substring(0, idx) + "_" + cs[j].getMainClusteringParameterValue() + p.substring(idx, p.length());
                
                File f = new File(p);
                
                boolean includeScores = chkIncludeScoring.getModel().isSelected();
                boolean includeProfiles = chkIncludeProfiles.getModel().isSelected();
                
                ArrayList<String> headerRow = new ArrayList<>();
                headerRow.add("ClusterID");
                headerRow.add("ProfileID");
                if (kgg) {
                    headerRow.add("Name");
                }

                //Assumes that all the cluster members have the same scores computed
                if (includeScores) {
                    cs[j].getClusters()[0].getComputedScores();
                    
                    for (Score.ScoringMethod s : cs[j].getClusters()[0].getComputedScores()) {
                        headerRow.add(s.toString());
                    }
                }
                
                if (includeProfiles) {
                    String[] param = cs[j].getDataset().getFeatureNamesCombined();
                    headerRow.addAll(Arrays.asList(param));
                }
                if (!kgg) {
                    rows.add(headerRow.toArray(new String[headerRow.size()]));
                }
                double scorePercentile = Double.parseDouble(txtLenThs.getText());
                int clusterIDX = 0;
                
                HashMap<Datapoint, Cluster> hmDpClus = new HashMap<Datapoint, Cluster>();
                ArrayList<Map.Entry<Datapoint, Double>> alEucl = new ArrayList<>();
                boolean exportQuantile = chkLenThs.getModel().isSelected();
                
                HashMap<String, Double> hmPSSs = new HashMap<>();
                for (Cluster c : cs[j].getClusters()) {
                    ClusterMember[] cmm = null;
                    try {
                        cmm = c.getClusterMembers();
                    } catch (SQLException ex) {
                        logger.showException(ex);
                    }
                    for (ClusterMember cm : cmm) {
                        hmDpClus.put(cm.getDatapoint(), c);
                        double score = MatrixOp.lenght(cm.getDatapoint().getVector());
                        /*                        if (cm.getScores().get((Score.ScoringMethod) cmbScoringMeasure.getSelectedItem()) != null) {
                         score = cm.getScores().get((Score.ScoringMethod) cmbScoringMeasure.getSelectedItem()).score;
                         }*/
                        
                        alEucl.add(new DefaultEntry<>(cm.getDatapoint(), score));
                        hmPSSs.put(cm.getDatapointName(), score);
                    }
                }
                /*
                 for (NDatapoint nd : d) {
                 if(hmPSSs.get(nd.getProfileID()) == null){
                 hmPSSs.put(nd.getProfileID(), UsePSS?1.0:cs.getChiSquareScorer().getScore(nd.getVector()));
                 alPSSs.add(UsePSS?1.0:cs.getChiSquareScorer().getScore(nd.getVector()));
                 }
                 }
                 */
                int pctIdx = Math.max(0, Math.min((int) Math.floor(cs[j].getDataset().size() * (1.0 - scorePercentile)), alEucl.size() - 1));
                double ths = -1;
                if (!exportQuantile) {
                    pctIdx = alEucl.size() - 1;
                }
                if (pctIdx < alEucl.size() - 1) {
                    Collections.sort(alEucl, new Comparator<Map.Entry<Datapoint, Double>>() {
                        @Override
                        public int compare(Map.Entry<Datapoint, Double> o1, Map.Entry<Datapoint, Double> o2) {
                            
                            return (int) Math.signum(o2.getValue() - o1.getValue());
                        }
                    });
                    ths = Double.parseDouble(txtLenThs.getText());// alEucl.get(pctIdx).getValue();
                }
                
                for (Cluster c : cs[j].getClusters()) {
                    int cntOverThs = 0;
                    try {
                        for (ClusterMember cm : c.getClusterMembers()) {
                            if (hmPSSs.get(cm.getDatapointName()) < ths) {
                                continue;
                            }
                            cntOverThs++;
                            String[] row = new String[headerRow.size()];
                            int i = 0;
                            row[i++] = String.valueOf(c.getID());
                            row[i++] = String.valueOf(cm.getDatapointName());
                            
                            if (includeScores) {
                                HashMap<Score.ScoringMethod, Score> scores = cm.getScores();
                                for (int k = 0; k < c.getComputedScores().size(); k++) {
                                    row[i + k] = String.valueOf(scores.get(c.getComputedScores().get(k)).score);
                                }
                                i += c.getComputedScores().size();
                            }
                            
                            if (includeProfiles) {
                                double[] vec = MatrixOp.concat(cm.getDatapoint().getVector(), cm.getDatapoint().getSideVector());
                                for (int t = 0; t < vec.length; t++) {
                                    row[i + t] = String.valueOf(vec[t]);
                                }
                                i += vec.length;
                            }
                            
                            if (kgg) {
                                row = new String[]{
                                    cm.getDatapointName(),
                                    cm.getDatapointName(),
                                    String.valueOf(clusterIDX)
                                };
                                
                                if (lookup && hmLookup.get(cm.getDatapointName()) != null) {
                                    row[0] = hmLookup.get(cm.getDatapointName());
                                }
                            }
                            rows.add(row);
                        }
                        if (cntOverThs > 0) {
                            clusterIDX++;
                        }
                    } catch (SQLException ex) {
                        Logger.getLogger(dlgExportClusterSet.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                
                try (BufferedWriter br = new BufferedWriter(new FileWriter(f))) {
                    StringBuilder sb = new StringBuilder();
                    int i = 0;
                    for (String[] row : rows) {
                        for (String s : row) {
                            sb.append(s);
                            sb.append("\t");
                        }
                        sb.deleteCharAt(sb.length() - 1);
                        sb.append("\n");
                        i++;
                        if (i == 1000) {
                            br.write(sb.toString());
                            sb = new StringBuilder();
                            i = 0;
                        }
                    }
                    br.write(sb.toString());
                    br.flush();
                    br.close();
                } catch (IOException e) {
                    logger.showException(e);
                }
            }
            JOptionPane.showMessageDialog(this, "Export done!");
            this.setVisible(false);
            
        }
    }//GEN-LAST:event_cmdExportActionPerformed

    private void chkLenThsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkLenThsActionPerformed
        //cmbScoringMeasure.setEnabled(chkLenThs.getModel().isSelected());
        //txtLenThs.setEnabled(chkLenThs.getModel().isSelected());
    }//GEN-LAST:event_chkLenThsActionPerformed
    /**
     * @param args the command line arguments
     */
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JCheckBox chkIncludeProfiles;
    private javax.swing.JCheckBox chkIncludeScoring;
    private javax.swing.JCheckBox chkLenThs;
    private samusik.glasscmp.GlassButton cmdExport;
    private javax.swing.JTextField txtLenThs;
    // End of variables declaration//GEN-END:variables
}
